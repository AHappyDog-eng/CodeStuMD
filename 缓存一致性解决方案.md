### 一般我们项目中采用的是

##### 如果我们进行 update 操作的时候 是先更新缓存再更新数据库

如果不是这样的话容易出现脏数据

比如：

ThreadA 访问数据A 并修改数据 ， 已经修改Db 还没有修改缓存， 此事ThreadB也请求数据A

进行操作，此时更新的缓存也更新了 数据库，这个时候ThreadA提交缓存 所以导致缓存不一致

是脏数据 缓存本应该是B的值 但是A最后提交变成了A的值

删除是先删除缓存

；

但是有问题 

比如ThreadA访问 先删除了缓存 还没有删除数据库 这个时候线程B 进行访问，没有命中缓存 ，查询数据库，结果又去更新了 数据库 ， 导致缓存不一致 永远都是脏数据了

解决办法 用延时双删策略进行删了



### 反射机制的原理 

反射 首先用Class.forName() 加载类信息 没有交给java 实例化 而是交给jvm 进行类的装载

每个类都有对应的一个Class 对象 没给类都有method 反射发放来作用到他身上

Class.forName() 加载类信息， 交给jvm进行加载主要是获取ClassLoader对象进行加载，调用native方法进行类的加载 最后使用 newInstance（） 方法来进行新建一个实例

使用 relactionData() 进行缓存保存；ReflectionData 的数据结构如下（软引用 ， 防止jvm加载过多造成内存损耗）

获取到 Constructor  就可以newInstance 来进行实例化了



Class.forName ->>>>> jvm 加载 执行native 方法， 使用relactionData 来进行缓存保存，获取到Constructor 就可以来实例化了

### 那接着问基础吧，TCP的可靠数据传输怎么保证的？

（发送确认，超时重传，快速重传，流量控制） 流量控制的过程



### MVCC的应用

行级锁

如果select 时刻 查询这两个版本，

满足条件 1 必须他的ID版本至少需要小于或者等于 当前事务的版本号 ，保证访问之前没有被修改

​                 2 必须他的删除版本号要没有别初始化 或者比当前事务小 保证访问之前 这个数据存在

insert    把当前事务作为 Id这一行的版本号

delect   吧当前事务作为Roll 这一行的版本号

update 会写一个当前行的拷贝 把他的旧版拷贝到 ID 和 Roll 行中， 进行保存 把拷贝的旧版数据作为当前事务的版本号，   增加了储存负担

 mysql> select a.* from member as a inner join (select id from member where gender=1 limit 300000,1) as b on a.id=b.id;

select * from member where gender=1 limit 300000,1;

先分析他的步骤 

通过索引查到所有gender =1  的主键值

通过这些主键 找到对应的数据块 根据id来进行查找到数据块

然后又limit 300000,1  查询300000 次索引为1 的数据块 ，最后放弃300000次取最后一个数据

limit 过大 导致查询效率很低下



解决方案，

先查出偏移后的主键，再根据所有的主键索引查询数据的所有内容就行啦

select A.* from member as a inner join (select * from member wherre gender =1 limit 300000,1) as b

on a.id = b.id



select a.*from table as a inner join (select *from table where meunber =1 limit 300000,1) as b on a.id = b.id



### 如何防止sql 注入

不管输入什么参数，打印出的SQL都是这样的。这是因为MyBatis启用了预编译功能，在SQL执行前，会先将上面的SQL发送给数据库进行编译；执行时，直接使用编译好的SQL，替换占位符“?”就可以了。因为SQL注入只能对编译过程起作用，所以这样的方式就很好地避免了SQL注入的问题。

　　【底层实现原理】MyBatis是如何做到SQL预编译的呢？其实在框架底层，是JDBC中的PreparedStatement类在起作用，PreparedStatement是我们很熟悉的Statement的子类，它的对象包含了编译好的SQL语句。这种“准备好”的方式不仅能提高安全性，而且在多次执行同一个SQL时，能够提高效率。原因是SQL已编译好，再次执行时无需再编译。

简单说，**#**{}是经过**预编译的**，是**安全的**；**$**{}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。



mybatis的一级缓存和二级缓存

mybatis的一级缓存 是默认开启的 二级缓存是关闭需要配置

一级缓存 和 session的相似 mybatis对相同的 sql会进行缓存 新建一个会话会有一块sqlsession区域进行对sql 语句的缓存 如果下一次还是这个缓存就直接返回 mybatis认为  如果是查询 条件相同就代表室同一个sql

二级缓存 需要配置

用<cache/>**** 标签进行开启缓存 ， 

工作模式 对所有查询语句都缓存 条件是 entity 实体类都必须继承实例化接口 

如果下次语句相同就直接返回

每次 update delte insert 都刷新缓存

内存不够的时候 采用Lru 最近最少使用



IO多路复用

客栈遇到的问题

从开始学习编程后，我就想开一个 Hello World 餐厅，由于一开始资金不足，所以只能开一个古老的小客栈。

客栈运营了几天，我发现我们的客栈存在着一个问题

我们的厨师只负责炒菜，炒好了放在一边继续炒其他菜，所以店小二必须经常进出厨房，一方面看看菜到底炒好了没有，如果炒好的话，就要把菜端出来，另一方面他必须得站在外面等候客人的其他需求。并且重要的是只有一个小二，他同时只能服务一个客人，其他客人必须等待
在客栈客人少的时候问题还不明显，有时候突然来个十几个客人，看到没人招待他，掉头就走了。

第一个解决方案（多线程）

给每一位顾客配备一名店小二。
这样一来，每一个顾客都有专门的小二负责，厨师一炒好菜，小二就将菜第一时间送到客人桌上，这样一来，客人的体验提升了很多，大家都非常满意，我客栈的名声也越来越好。

随着名声越来越好，客人也越来越多，渐渐地我发现，好像有什么地方不对。

随着客人越来越多，我必须招更多的店小二，支付更多的费用在小二身上，我发现，有时候付给员工的费用都比我赚的还多
第二个解决方案（select）

我将客栈进行改造，按照桌数区分，分为 1 2 3 4 四个区，每个区招一名店小二，来服务所在区的客人，并且对厨师进行了简单的培训，让他再炒好菜后大喊一声，有菜炒好了
这次简单升级后，我的客栈现在只有 4 个小二了，每个小二负责自己的区域，并且厨师炒好菜后，他大喊一声，来来来，菜炒好了，然后比如小二 1 号进入厨房，把菜端到他对应的区域挨个问，这菜是谁点的。

随着我的客栈越来越大越来越大，为了节省成本，我并没有再招更多的小二，依然是那四个小二。

直到有一天，1 区的客人爆满，达到了 1024 个了，那一天，我看着 1 区的小二每一次上菜几乎都是跑的，并且他告诉我，如果再多来一个客人，他就要挂了。
第三个解决方案（poll）

好吧，那个小二体力上好像跟不上节奏，所以我派人连夜赶工做了传说中的木牛流马来当店小二，这样一来，即使是 10240 个客人，一个木牛流马就 hold 住了
人数上限问题已经解决了，但是现在依然存在问题。

由于人数太多，每次要将做好的菜送到对应的客人桌上，必须挨个询问过去，这个步骤太慢了，很多次客人都不愿意等待而走掉了。
最终解决方案（epoll）

对木牛流马进行加工，使其可以记录每一个客人点的菜，然后厨师炒好菜后，只要报上菜名，木牛流马根据记录的订单，自动就将对应的菜端到客人桌中
有了这个解决方案，那么当一盘菜炒好后，就不必挨个确认是谁的菜了，如果新来了客人，同样只要记录下客人的菜单，提交给厨师，然后木牛流马又可以去招待其他客人了，当菜炒好后，直接就将菜送到客人那里了。

至此，生意兴荣，长盛不衰。

总结

select

只能监听 1024 个链接
并且没有返回具体可使用的 socket ,得挨个遍历
线程不安全
poll

没有链接数限制
依然线程不安全
epoll 
解决了 select poll 的问题，并且指定了 socket 回调



## select poll epoll

select 分区分块调用 最多1024 个连接 循环遍历socket

poll 没有了 1024限制 但是还是有 socker 遍历

epoll 没有 限制 并使用了 socket回掉 解决了 socker 遍历的问题

### 索引

1  主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。

2  主键创建后一定包含一个唯一性索引，唯一性索引不一定就是主键。

3   唯一性索引列允许空值， 而主键列不允许为空值。

4   主键可以被其他表引用为外键，而唯一索引不能。

5   一个表最多只能创建一个主键，但是可以创建多个唯一索引。

6   主键更适合那些不容易改变的唯一标识，如自动递增列，身份证号等。

7   在RBO 模式下，主键的执行计划优先级高于唯一索引。两者可以提高查询的速度。



### 线程进程的区别

1 一个应用程序可以有很有进程， 进程是分配资源的最小单位 线程是操作资源的最小调度单位

线程归属于进程

2 好处

多线程可以更好的应对并发场景，让多核cpu 发挥它的效果， 更好的配合进程调度

处理机分给线程，即真正在处理机上运行的是线程。

资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。



### int 和 Interger的区别

Interger 是对象 int是变量  Interger是int的包装器类

初始化  Integer是null int 是0

Integer 必须要初始化才可以用

会自动拆装箱int 和integer 自动拆装箱

### 网络模型

![这里写图片描述](https://img-blog.csdn.net/20180712131041807?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2MTkyOTQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)





排序 堆排序， 快排序 归并排序



### ThreadLocal 为什么要加 static 

ThreadLocal 为每一个线程来进行保存一个线程的副本 分开线程所以可以保证线程安全

如果不加static 的话 就会如果一个线程 new了两个ThreadLocal 就会导致不在同一作用域下来操作，

导致资源浪费

ThreadLocal 是解决线程安全的一个类型， 他自己内部来维护一个map集合 key是new的对象value 是对新建对象的value值来保存的，如果不加static 因为key 是弱引用 ， **弱引用**是在任何时刻，只要垃圾回收触发，就会被回收，key是弱引用导致key被回收 ， 弱引用key 指向的value 还在 ， 可能会导致内存泄漏

static 在类加载时装载 ， 在不用时刻销毁。很符合 ThreadLocal的定位



### 死锁的解决方案

1) 资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。

2) 撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。

3) 进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。

### 索引

如果id是无序的，那么很有可能新插入的值会导致当前节点分裂，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。

反之，如果每次插入有序，那就会在当前页后面连续写入，写不下就会重新分配一个节点，内存都是连续的，这样效率自然也就最高了。

### 重载和重写的区别

重载 **编译时** 的多态， 重写 **运行时** 多态

重载 发生在 同一个类中，重写发生在父子关系类中

答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。