### tcp层 是干嘛的？

tcp 输入传输层协议，保证两个服务器的互相通信

### tcp层的定义

tcp层面向连接的一层数据，是可靠地***流***  传输协议 保证两个程序点对点的传输

### 三次握手 为什么要三次握手

三次握手 客户端向服务器发送连接请求，请求连接 服务器如果可以接受连接 就返回信号 我可以接受传输， 服务器再次握手 用来保证确定可以接受数据 三次握手是要保证报文没有失效

如果没有第三次握手的话，比如 AClient ------> AServer ( 网络结点断网 ) AServer 没有收到请求 一段时间后 Aclient放弃对AServer的连接请求 但是这个时候AClient网络结点恢复了 请求又到了AServer 服务器响应，如果只有两次握手 就建立连接 ，这个时候AClient发送的请求已经失效，AServer就一直等待AClient的请求发送，就会极大的耗损资源

### tcp是流式传输的

何为流式传输： 意思代表为水流 因为流式传输没有界限，就很容易导致沾包

**沾包** 意思是Client传输的数据 分为很多包，但是到达服务器端又沾成了一个包，这就叫沾包

### 沾包的原因

1 tcp的复用性 多进程使用一个tcp连接 就很可能会出现沾包的状态

2 数据包过大，导致一部分先发送过去了，截取下来的那一部分 导致和后面的包一起发送了 就导致沾包的问题出现

### 沾包的解决办法

- 尾部标记序列。通过特殊标识符表示数据包的边界，例如\n\r，\t，或者一些隐藏字符。
- 头部标记分步接收。在TCP报文的头部加上表示数据长度。
- 应用层发送数据时定长发送。

### tcp 的详细机制

#### 应答机制

![img](https://img-blog.csdn.net/20181003165647565?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZyZWVkb21fMjIy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

每个字节的数据都设置了应答号 确认应答之后才会发送下一子 字节

#### 超时重发

![img](https://img-blog.csdn.net/20181003170526691?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZyZWVkb21fMjIy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



如果发送数据 如果超过一定的设置时间 没有应答之后 就会重新发送 知道确认应答之后，继续发送下一个字节

#### 滑动窗口

![img](https://img-blog.csdn.net/20181003174149980?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZyZWVkb21fMjIy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

如果每一个都要次次发送应答好并应答 就会很慢 ， 所以出现了 滑动窗口的形式来进行传输 一次发送多个来进行相应



#### 流量控制

如果网络的速度比较慢，tcp发送又很快 就会导致缓冲区满了，导致丢包，

##### 解决方案 ：

​	接受方把自己缓冲区大小放入应答区域之中， 发送方查看缓冲区大小 进行控制窗口的大小

​	如果缓冲区已经满了 ， 就把窗口大小设置为 **0** 代表不带接受数据

#### 拥塞机制

先把窗口设置为1 先发送一个 如果网络情况好的话 ， 就把窗口每次+1 进行传输，目的是尽快的发送信息到接收端口 ， 防止因为太多人上网导致的 网络堵塞

#### 延迟应答

接收方 先等待一会 先把缓冲区的数据给消耗完成， 如果缓冲区的大小变大了 ，返回的窗口的数量就自然变大了

系统就可以有更大的吞吐量



### http状态码

200 成功

301 永久重定向

302 临时重定向（拦截器）

400 服务器不理解 你的语法

401 没有授权访问（没有身份）

403  禁止访问

​              

404  没有资源可以访问

500 服务器内部出错

502 访问服务器没有得到有效的应答

504 服务器没有给你响应